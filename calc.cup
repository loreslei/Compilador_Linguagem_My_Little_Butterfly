import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.util.function.*;

parser code {:
    scanner s;
    Map<String, Object> vars = new HashMap<>();

    public parser(scanner s){ this.s = s; }

    /* --- CLASSE AUXILIAR PARA O SWITCH --- */
    static class CaseObs {
        Supplier<Object> value; 
        Runnable action;
        
        public CaseObs(Supplier<Object> val, Runnable act) {
            this.value = val;
            this.action = act;
        }
    }
:}

scan with {: return s.next_token(); :};

/* ---------- TERMINAIS ---------- */
terminal SEMI, PLUS, MINUS, TIMES, DIV, UMINUS;
terminal LPAREN, RPAREN, LBRACE, RBRACE;
/* Terminais de Vetor */
terminal LBRACK, RBRACK, COMMA; 

terminal IF, ELSE, WHILE, FOR, PRINT;
terminal COLON, SWITCH, CASE, DEFAULT; 
terminal IGUAL, NOT, MENOR_QUE, MAIOR_QUE, MENOR_IGUAL, MAIOR_IGUAL, GETS;
terminal Boolean TRUE, FALSE;
terminal Double NUMBER;
terminal String STRING;
terminal String WORD;

/* ---------- NÃO TERMINAIS ---------- */
non terminal Runnable stmt_list, stmt, if_stmt, while_stmt, for_stmt, block, switch_stmt;
non terminal Supplier<Object> expr, assignment_expr, any_expr;
non terminal Supplier<Boolean> bool_expr;

/* Switch */
non terminal List<CaseObs> case_list;
non terminal CaseObs case_item;

/* Vetores (Auxiliares para lista de argumentos [1, 2, 3]) */
non terminal List<Supplier<Object>> arg_list;

/* ---------- PRECEDÊNCIA ---------- */
precedence left IGUAL, NOT, MENOR_QUE, MAIOR_QUE, MENOR_IGUAL, MAIOR_IGUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS;
precedence left LBRACK; /* Alta precedência para acesso a vetor */
precedence right IF, ELSE;

/* ---------- START ---------- */
start with stmt_list;

/* ---------- REGRAS ---------- */

stmt_list ::=
        stmt_list:l stmt:s
        {:
            RESULT = () -> {
                if (l != null) l.run();
                if (s != null) s.run();
            };
        :}
      | stmt:s
        {: RESULT = s; :}
      ;

stmt ::=
        assignment_expr:a SEMI {: RESULT = () -> { a.get(); }; :}
      
      /* --- ATRIBUIÇÃO EM POSIÇÃO DE VETOR: vetor[0] = 10; --- */
      | WORD:nome LBRACK any_expr:idx RBRACK GETS any_expr:val SEMI
        {:
            RESULT = () -> {
                Object listaObj = vars.get(nome);
                Object indexObj = idx.get();
                Object valor = val.get();

                if (listaObj instanceof List && indexObj instanceof Double) {
                    List<Object> lista = (List<Object>) listaObj;
                    int i = ((Double) indexObj).intValue();
                    
                    // Garante tamanho (simples) ou lança erro se for OOB
                    if (i >= 0 && i < lista.size()) {
                        lista.set(i, valor);
                    } else {
                        System.err.println("Erro: Índice fora dos limites ou inválido: " + i);
                    }
                } else {
                    System.err.println("Erro: Variável '" + nome + "' não é um vetor ou índice inválido.");
                }
            };
        :}

      | any_expr:e SEMI        {: RESULT = () -> { e.get(); }; :}
      | if_stmt:i              {: RESULT = i; :}
      | while_stmt:w           {: RESULT = w; :}
      | for_stmt:f             {: RESULT = f; :}
      | switch_stmt:sw         {: RESULT = sw; :}
      | block:b                {: RESULT = b; :}
      | PRINT LPAREN any_expr:e RPAREN SEMI
        {:
            RESULT = () -> System.out.println(e.get());
        :}
      | SEMI {: RESULT = () -> {}; :}
      ;

/* Wrapper genérico (Object) */
any_expr ::= expr:e
             {: RESULT = e; :}
           | bool_expr:b
             {: RESULT = () -> (Object) b.get(); :}
           ;

/* ---------- EXPRESSÕES ---------- */
expr ::=
        expr:e1 PLUS  expr:e2    {: RESULT = () -> (Double)e1.get() + (Double)e2.get(); :}
      | expr:e1 MINUS expr:e2    {: RESULT = () -> (Double)e1.get() - (Double)e2.get(); :}
      | expr:e1 TIMES expr:e2    {: RESULT = () -> (Double)e1.get() * (Double)e2.get(); :}
      | expr:e1 DIV   expr:e2    {: RESULT = () -> (Double)e1.get() / (Double)e2.get(); :}
      | LPAREN expr:e RPAREN     {: RESULT = e; :}
      | NUMBER:n                 {: RESULT = () -> n; :}
      | MINUS expr:e             {: RESULT = () -> -(Double)e.get(); :} %prec UMINUS
      | STRING:s                 {: RESULT = () -> s; :}
      | WORD:nome
            {:
                RESULT = () -> {
                    Object val = vars.get(nome);
                    return (val == null) ? 0.0 : val;
                };
            :}
      
      /* --- CRIAÇÃO DE VETOR LITERAL: [1, 2, 3] --- */
      | LBRACK arg_list:args RBRACK
        {:
            RESULT = () -> {
                List<Object> novaLista = new ArrayList<>();
                for(Supplier<Object> s : args) {
                    novaLista.add(s.get());
                }
                return novaLista;
            };
        :}

      /* --- ACESSO A VETOR: nome[indice] --- */
      | WORD:nome LBRACK any_expr:idx RBRACK
        {:
            RESULT = () -> {
                Object listaObj = vars.get(nome);
                Object indexObj = idx.get();
                
                if (listaObj instanceof List && indexObj instanceof Double) {
                    List<Object> lista = (List<Object>) listaObj;
                    int i = ((Double) indexObj).intValue();
                    if (i >= 0 && i < lista.size()) {
                        return lista.get(i);
                    }
                }
                return 0.0; // Retorno padrão em caso de erro
            };
        :}
      ;

/* Regras auxiliares para lista de argumentos dentro de [] */
arg_list ::=
        arg_list:l COMMA any_expr:e
        {:
            l.add(e);
            RESULT = l;
        :}
      | any_expr:e
        {:
            List<Supplier<Object>> l = new ArrayList<>();
            l.add(e);
            RESULT = l;
        :}
      | /* vazio */
        {:
            RESULT = new ArrayList<>();
        :}
      ;

bool_expr ::=
        any_expr:e1 IGUAL       any_expr:e2  {: RESULT = () -> Objects.equals(e1.get(), e2.get()); :}
      | any_expr:e1 NOT         any_expr:e2  {: RESULT = () -> !Objects.equals(e1.get(), e2.get()); :}
      | expr:e1 MENOR_QUE   expr:e2  {: RESULT = () -> (Double)e1.get() < (Double)e2.get(); :}
      | expr:e1 MAIOR_QUE   expr:e2  {: RESULT = () -> (Double)e1.get() > (Double)e2.get(); :}
      | expr:e1 MENOR_IGUAL expr:e2  {: RESULT = () -> (Double)e1.get() <= (Double)e2.get(); :}
      | expr:e1 MAIOR_IGUAL expr:e2  {: RESULT = () -> (Double)e1.get() >= (Double)e2.get(); :}
      | TRUE                         {: RESULT = () -> true;  :}
      | FALSE                        {: RESULT = () -> false; :}
      | LPAREN bool_expr:b RPAREN    {: RESULT = b; :}
      ;

assignment_expr ::= WORD:nome GETS any_expr:val
      {:
          RESULT = () -> {
              Object v = val.get();
              vars.put(nome, v);
              return v;
          };
      :}
      ;

block ::= LBRACE stmt_list:l RBRACE {: RESULT = l; :};

/* ---------- ESTRUTURAS DE CONTROLE ---------- */
if_stmt ::=
        IF LPAREN any_expr:e RPAREN stmt:s
            {:
               RESULT = () -> {
                   Object val = e.get();
                   if (val instanceof Boolean && (Boolean)val) { s.run(); }
               };
            :}
        %prec ELSE
      | IF LPAREN any_expr:e RPAREN stmt:s1 ELSE stmt:s2
            {:
               RESULT = () -> {
                   Object val = e.get();
                   if (val instanceof Boolean && (Boolean)val) { s1.run(); } else { s2.run(); }
               };
            :}
      ;

while_stmt ::=
        WHILE LPAREN any_expr:e RPAREN stmt:s
            {:
               RESULT = () -> {
                   Object val = e.get();
                   while (val instanceof Boolean && (Boolean)val) {
                       s.run();
                       val = e.get();
                   }
               };
            :}
      ;

for_stmt ::=
        FOR LPAREN assignment_expr:init SEMI any_expr:cond SEMI assignment_expr:step RPAREN stmt:body
            {:
               RESULT = () -> {
                   init.get();
                   Object val = cond.get();
                   while (val instanceof Boolean && (Boolean)val) {
                       body.run();
                       step.get();
                       val = cond.get();
                   }
               };
            :}
      ;

/* ---------- SWITCH STATEMENT ---------- */

case_list ::=
        case_list:l case_item:i
        {:
            l.add(i);
            RESULT = l;
        :}
      | case_item:i
        {:
            List<CaseObs> l = new ArrayList<>();
            l.add(i);
            RESULT = l;
        :}
      ;

case_item ::=
        CASE any_expr:e COLON stmt:s
        {: RESULT = new CaseObs(e, s); :}
      | DEFAULT COLON stmt:s
        {: RESULT = new CaseObs(null, s); :}
      ;

switch_stmt ::=
        SWITCH LPAREN any_expr:target RPAREN LBRACE case_list:cases RBRACE
        {:
            RESULT = () -> {
                Object valAlvo = target.get();
                boolean executou = false;

                for (CaseObs c : cases) {
                    if (c.value != null) {
                        Object valCase = c.value.get();
                        if (Objects.equals(valAlvo, valCase)) {
                            c.action.run();
                            executou = true;
                            break; 
                        }
                    }
                }

                if (!executou) {
                    for (CaseObs c : cases) {
                        if (c.value == null) {
                            c.action.run();
                            break;
                        }
                    }
                }
            };
        :}
      ;