import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.util.function.*;

parser code {:
    scanner s;
    Map<String, Object> vars = new HashMap<>();

    public parser(scanner s){ this.s = s; 
    }
    @Override
    public void syntax_error(Symbol s) {
        // s.left guarda a LINHA
        // s.right guarda a COLUNA
        System.err.println("Erro de sintaxe na Linha " + s.left + ", Coluna " + s.right);
        
    }
    

    /* --- CLASSE AUXILIAR PARA O SWITCH --- */
    /* Armazena o par: Valor de Comparação + Código a executar */
    static class CaseObs {
        Supplier<Object> value; // null se for 'default'
        Runnable action;
        
        public CaseObs(Supplier<Object> val, Runnable act) {
            this.value = val;
            this.action = act;
        }
    }
:}

scan with {: return s.next_token(); :};

/* ---------- TERMINAIS ---------- */
terminal SEMI, PLUS, MINUS, TIMES, DIV, UMINUS;
terminal LPAREN, RPAREN, LBRACE, RBRACE;
terminal IF, ELSE, WHILE, FOR, PRINT;
terminal COLON, SWITCH, CASE, DEFAULT; /* Novos Terminais */
terminal IGUAL, NOT, MENOR_QUE, MAIOR_QUE, MENOR_IGUAL, MAIOR_IGUAL, GETS;
terminal Boolean TRUE, FALSE;
terminal Double NUMBER;
terminal String STRING;
terminal String WORD;

/* ---------- NÃO TERMINAIS ---------- */
non terminal Runnable stmt_list, stmt, if_stmt, while_stmt, for_stmt, block, switch_stmt;
non terminal Supplier<Object> expr, assignment_expr, any_expr;
non terminal Supplier<Boolean> bool_expr;

/* Novos Não Terminais para o Switch */
non terminal List<CaseObs> case_list;
non terminal CaseObs case_item;

/* ---------- PRECEDÊNCIA ---------- */
precedence left IGUAL, NOT, MENOR_QUE, MAIOR_QUE, MENOR_IGUAL, MAIOR_IGUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS;
precedence right IF, ELSE;

/* ---------- START ---------- */
start with stmt_list;

/* ---------- REGRAS ---------- */

stmt_list ::=
        stmt_list:l stmt:s
        {:
            RESULT = () -> {
                if (l != null) l.run();
                if (s != null) s.run();
            };
        :}
      | stmt:s
        {: RESULT = s; :}
      ;

stmt ::=
        assignment_expr:a SEMI {: RESULT = () -> { a.get(); }; :}
      | any_expr:e SEMI        {: RESULT = () -> { e.get(); }; :}
      | if_stmt:i              {: RESULT = i; :}
      | while_stmt:w           {: RESULT = w; :}
      | for_stmt:f             {: RESULT = f; :}
      | switch_stmt:sw         {: RESULT = sw; :} /* Adicionado */
      | block:b                {: RESULT = b; :}
      | PRINT LPAREN any_expr:e RPAREN SEMI
        {:
            RESULT = () -> System.out.println(e.get());
        :}
      | SEMI {: RESULT = () -> {}; :}
      ;

/* Wrapper genérico (Object) */
any_expr ::= expr:e
             {: RESULT = e; :}
           | bool_expr:b
             {: RESULT = () -> (Object) b.get(); :}
           ;

/* ---------- EXPRESSÕES ---------- */
expr ::=
        expr:e1 PLUS  expr:e2    {: RESULT = () -> (Double)e1.get() + (Double)e2.get(); :}
      | expr:e1 MINUS expr:e2    {: RESULT = () -> (Double)e1.get() - (Double)e2.get(); :}
      | expr:e1 TIMES expr:e2    {: RESULT = () -> (Double)e1.get() * (Double)e2.get(); :}
      | expr:e1 DIV   expr:e2    {: RESULT = () -> (Double)e1.get() / (Double)e2.get(); :}
      | LPAREN expr:e RPAREN     {: RESULT = e; :}
      | NUMBER:n                 {: RESULT = () -> n; :}
      | MINUS expr:e             {: RESULT = () -> -(Double)e.get(); :} %prec UMINUS
      | STRING:s                 {: RESULT = () -> s; :}
      | WORD:nome
            {:
                RESULT = () -> {
                    Object val = vars.get(nome);
                    return (val == null) ? 0 : val;
                };
            :}
      ;

bool_expr ::=
        any_expr:e1 IGUAL       any_expr:e2  {: RESULT = () -> Objects.equals(e1.get(), e2.get()); :}
      | any_expr:e1 NOT         any_expr:e2  {: RESULT = () -> !Objects.equals(e1.get(), e2.get()); :}
      | expr:e1 MENOR_QUE   expr:e2  {: RESULT = () -> (Double)e1.get() < (Double)e2.get(); :}
      | expr:e1 MAIOR_QUE   expr:e2  {: RESULT = () -> (Double)e1.get() > (Double)e2.get(); :}
      | expr:e1 MENOR_IGUAL expr:e2  {: RESULT = () -> (Double)e1.get() <= (Double)e2.get(); :}
      | expr:e1 MAIOR_IGUAL expr:e2  {: RESULT = () -> (Double)e1.get() >= (Double)e2.get(); :}
      | TRUE                         {: RESULT = () -> true;  :}
      | FALSE                        {: RESULT = () -> false; :}
      | LPAREN bool_expr:b RPAREN    {: RESULT = b; :}
      
      ;

assignment_expr ::= WORD:nome GETS any_expr:val
      {:
          RESULT = () -> {
              Object v = val.get();
              vars.put(nome, v);
              return v;
          };
      :}
      ;

block ::= LBRACE stmt_list:l RBRACE {: RESULT = l; :};

/* ---------- ESTRUTURAS DE CONTROLE EXISTENTES ---------- */
if_stmt ::=
        IF LPAREN any_expr:e RPAREN stmt:s
            {:
               RESULT = () -> {
                   Object val = e.get();
                   if (val instanceof Boolean && (Boolean)val) { s.run(); }
               };
            :}
        %prec ELSE
      | IF LPAREN any_expr:e RPAREN stmt:s1 ELSE stmt:s2
            {:
               RESULT = () -> {
                   Object val = e.get();
                   if (val instanceof Boolean && (Boolean)val) { s1.run(); } else { s2.run(); }
               };
            :}
      ;

while_stmt ::=
        WHILE LPAREN any_expr:e RPAREN stmt:s
            {:
               RESULT = () -> {
                   Object val = e.get();
                   while (val instanceof Boolean && (Boolean)val) {
                       s.run();
                       val = e.get();
                   }
               };
            :}
      ;

for_stmt ::=
        FOR LPAREN assignment_expr:init SEMI any_expr:cond SEMI assignment_expr:step RPAREN stmt:body
            {:
               RESULT = () -> {
                   init.get();
                   Object val = cond.get();
                   while (val instanceof Boolean && (Boolean)val) {
                       body.run();
                       step.get();
                       val = cond.get();
                   }
               };
            :}
      ;

/* ---------- SWITCH STATEMENT (NOVO) ---------- */

/* Lista de casos: constrói uma ArrayList de CaseObs */
case_list ::=
        case_list:l case_item:i
        {:
            l.add(i);
            RESULT = l;
        :}
      | case_item:i
        {:
            List<CaseObs> l = new ArrayList<>();
            l.add(i);
            RESULT = l;
        :}
      ;

/* Item individual: 'case X: stmt' ou 'default: stmt' */
case_item ::=
        CASE any_expr:e COLON stmt:s
        {:
            RESULT = new CaseObs(e, s);
        :}
      | DEFAULT COLON stmt:s
        {:
            // Default tem 'value' null para identificar
            RESULT = new CaseObs(null, s);
        :}
      ;

/* Lógica de execução do Switch */
switch_stmt ::=
        SWITCH LPAREN any_expr:target RPAREN LBRACE case_list:cases RBRACE
        {:
            RESULT = () -> {
                Object valAlvo = target.get(); // Valor do 'switch(X)'
                boolean executou = false;

                // 1. Tenta encontrar um case correspondente
                for (CaseObs c : cases) {
                    // Se não for default e os valores forem iguais
                    if (c.value != null) {
                        Object valCase = c.value.get();
                        if (Objects.equals(valAlvo, valCase)) {
                            c.action.run();
                            executou = true;
                            break; // Sai do switch após executar (Implicit Break)
                        }
                    }
                }

                // 2. Se nenhum case rodou, procura o default
                if (!executou) {
                    for (CaseObs c : cases) {
                        if (c.value == null) { // É o default
                            c.action.run();
                            break;
                        }
                    }
                }
            };
        :}
      ;