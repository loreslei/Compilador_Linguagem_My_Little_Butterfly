import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import java.util.function.*;

parser code {:
    scanner s;
    Map<String, Object> vars = new HashMap<>();

    public parser(scanner s){ this.s = s; }

    @Override
    public void syntax_error(Symbol s) {
        if (s != null) {
            String val = (s.value != null) ? s.value.toString() : "Token ID: " + s.sym;
            // Removi acentos aqui também para garantir
            System.err.println("Erro sintatico na Linha " + s.left + ", Coluna " + s.right + ". Perto de: " + val);
        } else {
            System.err.println("Erro sintatico: Fim de arquivo inesperado.");
        }
    }

    static class CaseObs {
        Supplier<Object> value; 
        Runnable action;
        public CaseObs(Supplier<Object> val, Runnable act) {
            this.value = val;
            this.action = act;
        }
    }
:}

scan with {: return s.next_token(); :};

/* ---------- TERMINAIS ---------- */
terminal SEMI, PLUS, MINUS, TIMES, DIV, UMINUS;
terminal LPAREN, RPAREN, LBRACE, RBRACE;
terminal LBRACK, RBRACK, COMMA; 

terminal IF, ELSE, WHILE, FOR, PRINT;
terminal COLON, SWITCH, CASE, DEFAULT; 
terminal IGUAL, NOT, MENOR_QUE, MAIOR_QUE, MENOR_IGUAL, MAIOR_IGUAL, GETS;
terminal Boolean TRUE, FALSE;
terminal Double NUMBER;
terminal String STRING;
terminal String WORD;

/* ---------- NÃO TERMINAIS ---------- */
non terminal Runnable program, stmt_list, stmt, if_stmt, while_stmt, for_stmt, block, switch_stmt;
non terminal Supplier<Object> expr, assignment_expr, any_expr;
non terminal Supplier<Boolean> bool_expr;

non terminal List<CaseObs> case_list;
non terminal CaseObs case_item;
non terminal List<Supplier<Object>> arg_list;

/* ---------- PRECEDÊNCIA ---------- */
precedence left IGUAL, NOT, MENOR_QUE, MAIOR_QUE, MENOR_IGUAL, MAIOR_IGUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left UMINUS;
precedence left LBRACK; 
precedence right IF, ELSE;

/* ---------- START ---------- */
start with program;

/* ---------- REGRAS ---------- */

program ::= stmt_list:l {: RESULT = l; :}
          | /* vazio */ {: RESULT = () -> {}; :}
          ;

stmt_list ::=
        stmt_list:l stmt:s
        {:
            RESULT = () -> {
                if (l != null) l.run();
                if (s != null) s.run();
            };
        :}
      | stmt:s
        {: RESULT = s; :}
      ;

stmt ::=
        assignment_expr:a SEMI {: RESULT = () -> { a.get(); }; :}
      | WORD:nome LBRACK any_expr:idx RBRACK GETS any_expr:val SEMI
        {:
            RESULT = () -> {
                Object listaObj = vars.get(nome);
                Object indexObj = idx.get();
                Object valor = val.get();
                if (listaObj instanceof List && indexObj instanceof Double) {
                    List<Object> lista = (List<Object>) listaObj;
                    int i = ((Double) indexObj).intValue();
                    if (i >= 0 && i < lista.size()) lista.set(i, valor);
                    // AQUI ESTAVA O ERRO: Removi acentos de "inválido"
                    else System.err.println("Erro: Indice invalido ou fora dos limites: " + i);
                } else {
                    System.err.println("Erro: '" + nome + "' nao e vetor.");
                }
            };
        :}
      | any_expr:e SEMI        {: RESULT = () -> { e.get(); }; :}
      | if_stmt:i              {: RESULT = i; :}
      | while_stmt:w           {: RESULT = w; :}
      | for_stmt:f             {: RESULT = f; :}
      | switch_stmt:sw         {: RESULT = sw; :}
      | block:b                {: RESULT = b; :}
      | PRINT LPAREN any_expr:e RPAREN SEMI
        {: RESULT = () -> System.out.println(e.get()); :}
      | SEMI {: RESULT = () -> {}; :}
      ;

any_expr ::= expr:e {: RESULT = e; :}
           | bool_expr:b {: RESULT = () -> (Object) b.get(); :}
           ;

expr ::=
        expr:e1 PLUS  expr:e2    {: RESULT = () -> (Double)e1.get() + (Double)e2.get(); :}
      | expr:e1 MINUS expr:e2    {: RESULT = () -> (Double)e1.get() - (Double)e2.get(); :}
      | expr:e1 TIMES expr:e2    {: RESULT = () -> (Double)e1.get() * (Double)e2.get(); :}
      | expr:e1 DIV   expr:e2    {: RESULT = () -> (Double)e1.get() / (Double)e2.get(); :}
      | LPAREN expr:e RPAREN     {: RESULT = e; :}
      | NUMBER:n                 {: RESULT = () -> n; :}
      | MINUS expr:e             {: RESULT = () -> -(Double)e.get(); :} %prec UMINUS
      | STRING:s                 {: RESULT = () -> s; :}
      | WORD:nome {: RESULT = () -> { Object v = vars.get(nome); return (v==null)?0.0:v; }; :}
      | LBRACK arg_list:args RBRACK
        {:
            RESULT = () -> {
                List<Object> l = new ArrayList<>();
                for(Supplier<Object> s : args) l.add(s.get());
                return l;
            };
        :}
      | WORD:nome LBRACK any_expr:idx RBRACK
        {:
            RESULT = () -> {
                Object l = vars.get(nome);
                Object id = idx.get();
                if (l instanceof List && id instanceof Double) {
                    return ((List)l).get(((Double)id).intValue());
                }
                return 0.0; 
            };
        :}
      ;

arg_list ::=
        arg_list:l COMMA any_expr:e {: l.add(e); RESULT = l; :}
      | any_expr:e {: List<Supplier<Object>> l = new ArrayList<>(); l.add(e); RESULT = l; :}
      | /* vazio */ {: RESULT = new ArrayList<>(); :}
      ;

bool_expr ::=
        any_expr:e1 IGUAL       any_expr:e2  {: RESULT = () -> Objects.equals(e1.get(), e2.get()); :}
      | any_expr:e1 NOT         any_expr:e2  {: RESULT = () -> !Objects.equals(e1.get(), e2.get()); :}
      | expr:e1 MENOR_QUE   expr:e2  {: RESULT = () -> (Double)e1.get() < (Double)e2.get(); :}
      | expr:e1 MAIOR_QUE   expr:e2  {: RESULT = () -> (Double)e1.get() > (Double)e2.get(); :}
      | expr:e1 MENOR_IGUAL expr:e2  {: RESULT = () -> (Double)e1.get() <= (Double)e2.get(); :}
      | expr:e1 MAIOR_IGUAL expr:e2  {: RESULT = () -> (Double)e1.get() >= (Double)e2.get(); :}
      | TRUE                         {: RESULT = () -> true;  :}
      | FALSE                        {: RESULT = () -> false; :}
      | LPAREN bool_expr:b RPAREN    {: RESULT = b; :}
      ;

assignment_expr ::= WORD:nome GETS any_expr:val
      {: RESULT = () -> { Object v = val.get(); vars.put(nome, v); return v; }; :}
      ;

block ::= LBRACE stmt_list:l RBRACE {: RESULT = l; :};

if_stmt ::=
        IF LPAREN any_expr:e RPAREN stmt:s
            {: RESULT = () -> { if ((Boolean)e.get()) s.run(); }; :} %prec ELSE
      | IF LPAREN any_expr:e RPAREN stmt:s1 ELSE stmt:s2
            {: RESULT = () -> { if ((Boolean)e.get()) s1.run(); else s2.run(); }; :}
      ;

while_stmt ::=
        WHILE LPAREN any_expr:e RPAREN stmt:s
            {: RESULT = () -> { while ((Boolean)e.get()) s.run(); }; :}
      ;

for_stmt ::=
        FOR LPAREN assignment_expr:init SEMI any_expr:cond SEMI assignment_expr:step RPAREN stmt:body
            {:
               RESULT = () -> {
                   init.get();
                   while ((Boolean)cond.get()) { body.run(); step.get(); }
               };
            :}
      ;

case_list ::= case_list:l case_item:i {: l.add(i); RESULT=l; :} | case_item:i {: List<CaseObs> l=new ArrayList<>(); l.add(i); RESULT=l; :};
case_item ::= CASE any_expr:e COLON stmt:s {: RESULT=new CaseObs(e,s); :} | DEFAULT COLON stmt:s {: RESULT=new CaseObs(null,s); :};
switch_stmt ::= SWITCH LPAREN any_expr:target RPAREN LBRACE case_list:cases RBRACE
    {:
        RESULT = () -> {
            Object t = target.get();
            boolean run = false;
            for(CaseObs c : cases) if(c.value!=null && Objects.equals(t, c.value.get())) { c.action.run(); run=true; break; }
            if(!run) for(CaseObs c : cases) if(c.value==null) { c.action.run(); break; }
        };
    :};